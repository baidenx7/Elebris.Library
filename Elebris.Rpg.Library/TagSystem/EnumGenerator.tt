<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".generated.cs" #>
<#@ Assembly Name="EnvDTE.dll" #>
<#@ Assembly Name="System.Data" #>
<#@ Assembly Name="System.Core" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.SqlClient" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Linq" #>
<#
//https://exceptionnotfound.net/creating-csharp-enums-from-a-sql-database-using-t4-text-templates/
    //By default, we use these names for the columns we are querying from.
    string columnId = "id";
    string columnName = "Name";
    string columnDescription = "Description";
    string columnTypeCode = "typeCode";
    string connectionString = "YOUR CONNECTION STRING";
 
    //We need to get the containing project in order to know what project
    //to add the generated C# files to. In our case, we have a dedicated C#
    //project that has nothing except this template and the generated
    //enums in it.
    IServiceProvider serviceProvider = (IServiceProvider)Host;
    DTE dte = (DTE)serviceProvider.GetService(typeof(DTE));
    Project project = dte.Solution.FindProjectItem(Host.TemplateFile).ContainingProject;
#>
using System;
using System.CodeDom.Compiler;
using System.ComponentModel.DataAnnotations;
using System.Linq;
 
namespace MyProject.Enums
{
    /// <summary>
    /// <#= tableName #> auto generated enumeration
    /// </summary>
    [GeneratedCode("TextTemplatingFileGenerator", "10")]
    public enum <#= className #>
    {
<#
    SqlConnection conn = new SqlConnection(connectionString);
    //You may want to add a WHERE or ORDER BY clause to this query.
    string command = string.Format("select {0}, {1}, {2}, {3} from {4}", columnId, columnName, columnDescription, columnTypeCode, tableName);
    SqlCommand comm = new SqlCommand(command, conn);
 
    conn.Open();
 
    SqlDataReader reader = comm.ExecuteReader();
    bool loop = reader.Read();
 
    while(loop)
    {
#>
        [Display(Name = "<#= MakeSafeForString(reader[columnName]) #>", Description = "<#= MakeSafeForString(reader[columnName]) #>")]
        <#= CreateName(reader[columnTypeCode]) #> = <#= reader[columnId] #><# loop = reader.Read(); #><#= loop ? ",\r\n" : string.Empty #>
<#
    }
#>  }
}
<#+

    //This method makes the value safe for a string value by limiting
    //the characters to alphanumeric, parentheses, and hyphens.
    private string MakeSafeForString(object value)
    {
        Regex rx = new Regex(@"[^a-zA-Z0-9 \(\)\/-]");
        return rx.Replace(value.ToString(), "");
    }

    //Creates the name of the enum, using alphanumerics, 
    //parentheses, and underscores.
    //If the first character is a number, 
    //appends a "T" to the beginning of the value
    //and makes that the name.
    private string CreateName(object value)
    {
        Regex rx = new Regex(@"[^a-zA-Z0-9 \(\)\/_]");
        string typeCode = rx.Replace(value.ToString(), "");
        bool isDigit = char.IsDigit(typeCode[0]);
        if(isDigit)
        {
            return "T" + typeCode;
        }
        else
        {
            return FirstLetterToUpperCase(typeCode);
        }
    }

    // Returns the input string with the first 
    // character converted to uppercase
    public string FirstLetterToUpperCase(string s)
    {
        if (string.IsNullOrEmpty(s))
            throw new ArgumentException("There is no first letter");

        char[] a = s.ToCharArray();
        a[0] = char.ToUpper(a[0]);
        return new string(a);
    }
#>
